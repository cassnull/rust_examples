### Heapsort. ###

Необходимо отсортировать массив $A$, размером $b$. Построим на базе этого массива за $O(n)$ кучу для максимума. Так как максимальный элемент находится в корне, то если поменять его местами с $A[n − 1]$, он встанет на своё место. Далее вызовем процедуру $siftDown(0)$, предварительно уменьшив $heapSize$ на $1$. Она за $O(log(n))$ просеет $A[0]$ на нужное место и сформирует новую кучу (так как мы уменьшили её размер, то куча располагается с $A[0]$ по $A[n − 2]$, а элемент $A[n−1]$ находится на своём месте). Повторим эту процедуру для новой кучи, только корень будет менять местами не с $A[n − 1]$, а $A[n−2]$. Делая аналогичные действия, пока $heapSize$ не станет равен $1$, мы будем ставить наибольшее из оставшихся чисел в конец не отсортированной части. Очевидно, что таким образом, мы получим отсортированный массив.

| лучшее время | среднее | худшее | память |
|:------------:|:-------:|:------:|:------:|
| $O(n \times log(n))$ | $O(n \times log(n))$ | $O(n \times log(n))$ | $O(n)$ |